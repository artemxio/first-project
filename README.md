# BASH tips<br>

cd – сменить директорию<br>
&emsp; ~ домашняя директория<br>
&emsp; .. на уровень выше<br>
&emsp;. текущая директория (когда нужно запустить скрипт и передать папку в качестве параметра)<br>

pwd – показать путь текущей директории<br>
ls – показать файлы текущей директории<br>
&emsp; -la в виде списка<br>
&emsp; -а – все, включая скрытые (начинаются с .)<br>

touch – создать файл<br>
mkdir – создать директорию<br>
&emsp; -p создать структуру директорий<br>

cp – копирование файлов<br>
mv – перемещение файлов и папок<br>
cat – чтение файлов<br>
rm, rmdir, rm - r – удаление файлов и папок<br>
&emsp; && – несколько команд<br>

git config – конфигурация git<br>
&emsp; git config --global user.name "User Namovich" # имя или ник нужно написать латиницей и в  кавычках<br>

git init – создание репозитория в папке<br>
rm -rf .git - разгитить<br>
&emsp; ключ -r (от англ. recursive — «рекурсивно») позволяет удалять папки вместе с их содержимым;<br>
&emsp; ключ -f (от англ. force — «заставить») избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?».<br>

git status – проверить состояние репозитория<br>
git add – подготовить файлы к сохранени. Пример git add --all (добавить все файлы) git add . (добавить всю текущую папку)<br>
git commit – выполнить коммит<br>
&emsp; -m – добавить сообщение (комментарий)<br>

clip < ~/.ssh/id_ed25519.pub – скопировать содержимое файла с ключом в буфер<br>
git log – история коммитов<br>
&emsp; --oneline - сокращенный лог
git config --global user.email username@yandex.ru # здесь нужно указать свой настоящий email<br>
ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" – создать ключ<br>
git remote add – привязать удаленный репозиторий к локальному<br>
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git<br>
&emsp; Где origin – имя удаленного репозитория<br>

git remote –v – убедиться, что репозитории связаны<br>
git push -u origin main – первый пуш. Где origin имя удаленного репозитория, а main (master) – название текущей ветки. -u связывает удаленную ветку и локальную<br>
&emsp; --force - принудительный пуш, если обновляемая ветка в репозитории старше, чем в локальном (например, был откат коммита)

git commit --amend --no-edit  - обновить/исправить последний коммит (внести изменения без добавления нового коммита)<br>
git commit --amend -m - изменить сообщение коммита<br>
git restore --staged <file> - выполнить unstage изменений (до коммита)<br>
git reset --hard <commit hash> - откат к указанному коммиту<br>
git restore <file> - откатить изменения, которые не попали ни в staging, ни в коммит (если случайно отредактирован файл и теперь попал в modified)<br>
git diff - посмотреть какие изменения были сделаны в коммите<br>
&emsp; staged - посмотреть изменения в staged (после add)<br>
&emsp; git diff <название_ветки1> <название_ветки2> - сравнить ветки<br>
&emsp; &emsp; ~N (где N - число) - сравнение с коммитом -N от указанного коммита

.gitignore - файл, в котором можно перечислить файлы, которые не должны трекаться, например:<br>

&emsp;.DS_Store<br>

&emsp; # игнорировать все файлы, которые заканчиваются на .jpeg<br>
&emsp; *.jpeg<br>

&emsp; # игнорировать все файлы "tmp" во всех подпапках папки docs<br>
&emsp; docs/*/tmp<br>

&emsp; # игнорировать файлы file0.txt, file1.txt и file2.txt<br>
&emsp; # при этом не игнорировать file3.txt, file4.txt, ...<br>
&emsp; file[0-2].txt <br>

&emsp; file?.txt - будут проигнорированы, например, файлы fileA.txt и file1.txt. А вот файл file12.txt не будет проигнорирован, потому что в его названии два символа после file, а не один.<br>

&emsp; # игнорировать todo.txt в корне репозитория<br>
&emsp; /todo.txt<br>

&emsp; # для сравнения: spam.txt будет игнорироваться во всех папках<br>
&emsp; spam.txt<br>

&emsp; # игнорировать папку build<br>
&emsp; build/ <br>

&emsp; # игнорировать файлы "docs/current/tmp", "docs/old/tmp",<br>
&emsp; # а также "docs/old/saved/a/b/c/d/tmp"<br>
&emsp; # и даже "docs/tmp", потому что ноль вложенных папок тоже подходит<br>
&emsp; docs/**/tmp<br>

&emsp; # игнорировать только "docs/current/tmp" и "docs/old/tmp"<br>
&emsp; # файл "docs/old/saved/a/b/c/d/tmp" не попадает в правило<br>
&emsp; docs/*/tmp <br>

&emsp; # игнорировать все JPEG-файлы<br>
&emsp; *.jpeg<br>

&emsp; # но только не мем с Doge<br>
&emsp; !doge.jpeg <br>

&emsp; !# игнорировать все файлы в каталоге build<br>
&emsp; !build/<br>

&emsp; !# игнорировать все .log файлы<br>
&emsp; !*.log<br>
 
&emsp; !# не игнорировать *.log файлы в examples<br>
&emsp; !# потому что это пример для документации<br>
&emsp; !!examples/**/*.log <br>

git status --ignored - отобразить игнорируемые файлы<br>

git clone - клонирование репозитория<br>
git remote - v - проверить связку репозиториев<br>

git branch <название_ветки> - создать ветку<br>
git checkout <название_ветки> - переключиться на ветку<br>
&emsp; -b <название_ветки> - создать ветку и сразу переключиться на неё 
git<br>

git merge <название_ветки> - выполнить слияние ветки (мерж)<br>
git branch -D <название_ветки> - удалить ветку после объединения<br>
&emsp; -d - удалить с проверкой (был ли merge)<br>

git push - отправить ветку в удалённый репозиторий<br>
&emsp; --set-upstream origin  <название ветки> - установить удаленную ветку для текущей локальной ветки по-умолчанию<br>


Алгоритм-шпаргалка для создания PR
01. Склонировать репозиторий.<br>
01.1 Если вы не участник проекта, предварительно сделать «форк» исходного репозитория.<br>
01.2 На странице репозитория или «форка» нажать кнопки: Code → SSH → скопировать ссылку.<br>
01.3 Выполнить команду git clone <ссылка на репозиторий>.<br>
02. Создать ветку для вашей задачи: git checkout -b my-task-branch-name.<br>
03. Добавить и «закоммитить» изменения, которые вы хотите внести в проект.<br>
04. «Запушить» ветку: git push --set-upstream origin HEAD или git push -u origin my-task-branch-name.<br>
04.1 GitHub (с помощью Git) выведет ссылку на создание PR. По ней нужно перейти.<br>
04.2 PR можно также создать через интерфейс GitHub.<br>
05. Сообщить о пул-реквесте ревьюеру.<br>
05.1 Иногда ревьюеры назначаются автоматически, тогда сообщать не нужно.<br>
06. Обсуждать с ревьюером предлагаемые изменения и вносить правки, пока эти изменения не будут одобрены (пока не будет получен «апрув»).<br>  
06.1 Если кто-то добавил конфликтующие изменения в main, пока ваш PR был на ревью, нужно разрешить конфликт: <br> 
- Обновить main: git checkout main && git pull.<br>
- Влить main в свою ветку: git checkout my-task-branch-name && git merge main.<br>
- Разрешить конфликты слияния с помощью IDE или вручную.<br>
- Создать коммит слияния: git commit --no-edit или git commit -m 'merge main'.<br>
- Сделать git push своей ветки.<br>
07. Нажать кнопку Merge или подождать, пока её нажмёт кто-то ещё.<br>
08. Ещё раз обновить main, чтобы «подтянуть» ваши изменения в основную ветку локального репозитория: git checkout main && git pull.<br>
09. Вы великолепны! Можете начинать снова со второго пункта.<br>

Алгоритм-шпаргалка для разрешения конфликтов слияния<br>
01. Открыть проект в IDE (VS Code, IDEA или другие).<br>
02. Открыть файл, в котором есть конфликт.<br>
03. Выбрать, какие части файла нужно взять из одной ветки, а какие — из другой.<br>
04. Когда конфликты разрешены, сделать коммит: git commit --no-edit или git commit -m 'merge branch <название ветки>'.<br>


Пример mermaid-схемы:<br>

```mermaid
graph LR;
  untracked -- "git add" --> staged;
  staged    -- "???"     --> tracked/comitted;

%% стрелка без текста для примера: 
  A --> B;
``` 
